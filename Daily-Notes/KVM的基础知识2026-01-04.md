文章分为两个部分  
**KVM虚拟化基础**（包含虚拟化的基础知识，KVM基础知识，基本KVM平台搭建，测试创建一个虚拟机）  
**使用命令管理虚拟机**（KVM图形化管理和命令行管理）

# 虚拟化软件KVM
## KVM虚拟化基础
### 虚拟化是什么
#### 虚拟化简介
>虚拟化的本质是抽象与隔离。通过一个名为 Hypervisor（虚拟机监控器） 的中间软件层，将一台物理服务器的资源池化，然后按需分配给多个独立的虚拟机（VM）。
#### 虚拟化的特征
抽象（Abstraction）： 软件不再直接看到物理硬件，而是看到 Hypervisor 模拟出来的虚拟硬件（虚拟CPU、虚拟显卡等）。

隔离（Isolation）： 每个虚拟机都是一个“沙箱”，其中一个死机或中毒，完全不影响主机和其他虚拟机。

池化（Pooling）： 把分散的硬件资源集中起来，像水库供水一样灵活调配。
#### 虚拟化优势
>提高资源利用率  
降低成本  
快速部署  
高可用
#### 虚拟化分类
网络虚拟化  
>网络虚拟化（Network Virtualization） 是指将物理网络资源（如交换机、路由器、网卡、防火墙）从硬件中脱离出来，通过软件实现对网络资源的逻辑隔离、池化和自动化管理

存储虚拟化  
>存储虚拟化（Storage Virtualization） 是指将多个物理存储设备（硬盘、阵列、云存储）整合为一个逻辑上的“资源池”。

桌面虚拟化  
>将操作系统（如 Windows）从物理终端（笔记本、PC）中剥离出来，统一运行在机房的服务器上。 用户通过网络，使用瘦客户机、平板甚至手机连接并操作这个桌面。

服务器虚拟化  
>服务器虚拟化就是将一台物理服务器转变为多台相互隔离的虚拟机（VM）的技术

容器虚拟化
>容器虚拟化不再模拟整套硬件，而是直接运行在宿主机的操作系统内核之上
#### 架构分类
Type-1  
>直接装在硬件上（比如提供一个镜像直接在硬件上安装）  
安全性更高
典型软件：VMware ESXi、Hyper-V、KVM

Type-2  
>装在现有系统
安全性较低
典型软件：VMware Workstation、VirtualBox、Xen、QEMU
#### 技术实现路径
全虚拟化  
>虚拟机（Guest OS）不知道自己被虚拟化了，它会发出只有硬件能懂的“敏感指令”。Hypervisor 必须拦截这些指令，通过二进制翻译（Binary Translation）把指令转换后再发给物理 CPU。  

半虚拟化
>虚拟机知道自己是虚的。通过修改虚拟机的操作系统内核，把那些麻烦的指令直接换成 Hypercall（超调用）。这相当于给虚拟机和硬件之间修了一条“特供高速路”。  

硬件辅助虚拟化
>CPU 厂商（Intel/AMD）直接在芯片里加了功能。它不需要软件去翻译（全虚拟化），也不需要修改系统内核（半虚拟化）。CPU 自己就能识别这是否是虚拟机的请求，并自动完成隔离和切换。

#### 虚拟化方式hypervisor
hypervisor  
>Hypervisor是一种运行在基础物理服务器和操作系统之间的中间软件层，其可以允许多个VM操作系统和
VM应用共享宿主机底层的内存、CPU、磁盘等物理硬件，也可叫做VMM（ virtual machine monitor），
即虚拟机监视器。
Hypervisor是所有虚拟化技术的核心，非中断地支持多工作负载迁移的能力是Hypervisor的基本功
能，当服务器启动并执行Hypervisor时，它会给每一台虚拟机分配适量的内存、CPU、网络和磁盘，并加载所
有虚拟机的客户操作系统。

hypervisor的特点
>Hypervisor 允许多种操作系统在相同的物理系统中运行
Hypervisor 控制硬件并向来宾操作系统提供访问底层硬件的途径
Hypervisor 向来宾操作系统提供虚拟化的硬件
#### 权限保护
CPU为了保证程序代码执行的安全性、多用户的独立性、保护OS的正常运行，提出了CPU执行状态的概
念。

这样能够限制不同程序之间的访问能力，避免一个程序获取另一个程序的内存数据造成数据混乱，同时也
避免了程序错误的操作物理硬件。一般CPU都会划分为 用户态 和内核态 ，x86的CPU架构更是细分为了
Ring3~0四种状态。
#### 用户态和内核态
运行在用户态的程序代码需要受到CPU的检查，用户态程序代码只能访问内存页表项中规定能被用户态程
序代码访问的页面虚拟地址(受限的内存访问)，而且还只能访问任务描述符TSS中的I/O Permission
Bitmap中规定能被用户态程序代码访问的端口。甚至不能直接访问外围硬件设备、不能抢占CPU。

所有的应用程序都运行在用户态上。当运行在用户态的Application需要调用只能被核心态代码直接访问
的硬件设备时，CPU会通过特别的接口去调用核心态的代码，以此来实现Application对硬件设备的调用。
#### 内核态
是Host OS Kernel运行的模式，运行在核心态的代码可以无限制的对系统内存、设备驱动程序、网卡接
口、显卡接口等外围硬件设备进行访问。

只有Host OS能够无限制的访问磁盘、键盘等外围硬件设备的数据，
但是首先需要在Host OS上安装驱动程序。
### KVM简介
#### KVM的定位
KVM（Kernel-based Virtual Machine）既是全虚拟化解决方案，也是硬件辅助虚拟化解决方案

KVM也是Type-II虚拟化，尽管KVM是Type-II虚拟化实现方式，但它仍然具有高性能和广泛的功能特性。KVM利用Linux内核的调
度程序和其他功能来优化虚拟机的性能，并提供了丰富的管理工具和功能，使其成为当前主流的开源服务器虚拟
化技术之一。

需要注意的是，虽然KVM本身属于Type-II虚拟化，但在某些情况下，通过特定的配置和优化，KVM可以
实现接近Type-I虚拟化的性能水平。
#### KVM简介
KVM是开源软件，可运行多个运行未修改的Linux或Windows映像的虚拟机，依赖于HVM；Intel VT-x,
AMD AMD-V
#### KVM的原理
KVM 本身不执行任何硬件模拟，需要使用一个客户空间的程序通过 /dev/kvm 接口设置一个客户机虚拟
服务器的地址空间，向它提供模拟的 I/O，并将它的视频显示映射回宿主的显示屏。目前这个应用程序通常使用QEMU。

kvm依赖于HVM技术，只能运行在支持硬件虚拟化的CPU上，也就是说CPU支持VT-x或AMD-v，并且只支
持x86_64bits系统。

只要基于硬件的操作系统内核一旦装载了kvm模块，那么kvm模块就和linux内核组合成
了hypervisor，变成了type-I模型的虚拟机。

kvm类似于寄生虫，linux内核一旦被寄宿，就没有自主权，跟着kvm一起变成hypervisor的一部分。

原来的用户空间就变成了hypervisor的管理控制台运行位置，而kvm以字符设备/dev/kvm的形式作为kvm整
个的调用管理接口。

kvm创建的虚拟机就是一个进程，ps查看，kill杀死
#### KVM的优势
>支持 CPU 和 memory 超载（Overcommit）  
支持 半虚拟化I/O （virtio）  
支持 热插拔 （cpu，块设备、网络设备等）  
支持 多存储管理  
支持 实时迁移（Live Migration）  
支持 PCI 设备直接分配和 单根I/O 虚拟化 （SR-IOV）  
支持 内核同页合并 （KSM ）  
支持 NUMA （Non-Uniform Memory Access，非一致存储访问结构 ）
#### kvm实现细节
KVM：
初始化CPU硬件,打开虚拟机模式,负责CPU,内存,中断控制器,时钟. 由内核模块kvm_xxx.ko实现，工
作于hypervisor，设备/dev/kvm，是一个字符设备，在用户空间可通过ioctl()系统调用来完成VM创建、
启动，为VM分配内存、读写VCPU的寄存器、向VCPU注入中断、时钟等管理功能  
QEMU进程：
工作于用户空间，主要用于实现模拟IO设备,如显卡，网卡，硬盘等， qemu-kvm进程：工作于用户空
间，用于实现一个虚拟机实例  
Libvirt：提供统一api，守护进程，libvertd和相关工具，如virsh，virt-manager
### 部署KVM
#### 我自己的实验环境
设备DELL笔记本i5-13450H 16G  
宿主机搭建VMware Workstation 17Pro  
宿主机镜像Rocky Linux 9.7  
KVM虚拟机镜像CentOS-7-x86_64-Minimal-2009.iso
#### 宿主机搭建
使用VMware Workstation 17Pro 创建一台Rocky Linux 9.7 4H 8G 最小化安装
#### 虚拟调整
进入虚拟机，查看是否支持虚拟化

确保CPU支持HVM  
`egrep '(vmx|svm)' /proc/cpuinfo`  
确认支持模块  
`lsmod | egrep 'kvm|Module'`
#### kvm工具包
qemu-kvm:为kvm提供底层仿真支持  
libvirt-daemon:libvirtd守护进程，管理虚拟机  
libvirt-client:用户端软件，提供客户端管理命令  
libvirt-daemon-driver-qemu:libvirtd连接qemu的驱动  
libvirt:使用最多的KVM虚拟化管理工具和应用程序接口，即通过libvirt调用KVM创建虚拟机，  
libvirt:是KVM通用的访问API，其不但能管理KVM，还能管理VMware、Xen、Hyper-V、virtualBox等虚拟化
方案。    
virt-install: 虚拟机命令行安装工具  
virsh:命令行工具是基于 libvirt API 创建的命令行工具，它可以作为图形化的 virt-manager 应用的备
选工具。  
virsh 命令可以被用来创建虚拟化任务管理脚本，如安装、启动和停止虚拟机  
virt-viewer:通过 VNC 和 SPICE 协议显示虚拟机器图形控制台的最小工具。该工具在其同名软件包中：
virtviewer  
cockpit:Web管理界面
#### Rocky搭建kvm
`yum install epel-release`  
`yum install qemu-kvm libvirt virt-manager virt-install virt viewer bridge-utils`  
`systemctl enable --now libvirtd`  
web管理界面  
` yum install cockpit cockpit-machines`  
默认情况下，该软件禁用了root用户登录，取消禁用  
` vim /etc/cockpit/disallowed-users`  
注释root行  
`systemctl enable --now cockpit`

浏览器访问本地虚拟机ip：9090

使用web管理界面创建虚拟机  

创建一个文件夹  
` mkdir /data/images -p`  
在该目录上传一个测试镜像，我这里使用CentOS-7-x86_64-Minimal-2009.iso
![](https://github.com/SparkySunny/LevelingUpDaily/blob/main/picture/cockpit%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA.png)
## 使用命令管理虚拟机
### 创建虚拟机
#### 基础知识
![](https://github.com/SparkySunny/LevelingUpDaily/blob/main/picture/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7.png)
主流的 KVM + Libvirt 体系
>virsh  
virt-install  
qemu-img  
#### 配置结构
安装完毕kvm之后，会形成一个专用的目录结构  
`ls /etc/libvirt/`

注意：
qemu目录是我们创建虚拟机后，保存虚拟机配置文件的目录
#### virt-install命令解读
基础资源配置  
>--name	虚拟机名称。必须在宿主机上唯一。  
--memory	内存大小。默认单位 MiB。  
--vcpus	虚拟 CPU 核心数。  
--os-variant	操作系统优化。让 Hypervisor 自动调整性能参数。 

存储与磁盘设置 (--disk)    
常用写法： --disk path=/var/lib/libvirt/images/vm1.qcow2,size=40,format=qcow2,bus=virtio  >
>path: 磁盘映像文件的物理路径。  
size: 自动创建磁盘的大小（GB）。  
format: 磁盘格式，建议用 qcow2（支持快照）。  
bus: 总线类型，强烈建议指定为 virtio。  

网络配置 (--network)
>桥接模式 (Bridge)： 虚拟机拥有局域网独立 IP。 --network bridge=br0,model=virtio  
NAT 模式 (Default)： 虚拟机通过宿主机上网。 --network network=default,model=virtio  

安装源设置
>--cdrom	使用本地 ISO 镜像 安装。  
--location	使用 网络安装源（支持 HTTP/FTP/NFS）。  
--import	跳过安装过程，直接导入现有的磁盘。

显示与远程管理 (--graphics)  
vnc	开启 VNC 访问。常用：--graphics vnc,listen=0.0.0.0  
spice	高性能桌面协议。常用：--graphics spice  
none	无图形界面。常配合命令行控制台：--extra-args="console=ttyS0"  
#### qemu-img创建磁盘
qemu-img create -f raw /opt/CentOS-7-x86_64.raw 10G
Formatting '/opt/CentOS-7-x86_64.raw', fmt=raw size=10737418240  
>create QEMU 的磁盘管理工具，用于创建、转换及修改虚拟机镜像。  
-f raw 指定镜像格式为 raw（原始格式）。如果不加此参数，默认通常也是 raw。  
/opt/CentOS-7...  虚拟磁盘存储的位置及文件名。
10G	磁盘容量  

其他命令  
>qemu-img info /opt/CentOS-7-x86_64.raw 查看镜像信息  
qemu-img convert -f raw -O qcow2 /opt/CentOS-7-x86_64.raw /opt/CentOS-7.qcow2  转换镜像格式

>查看效果 ls -lh /opt/

#### 创建虚拟机
`virt-install --virt-type kvm --name CentOS-7-x86_64 --memory
1024 --cdrom=/data/images/CentOS-7-x86_64-Minimal-2009.iso --disk=/opt/CentOS-7-
x86_64.raw --network network=default --graphics vnc,listen=0.0.0.0 --
noautoconsole`

参数解析：
--virt-type kvm 指定创建的虚拟机基于的虚拟化技术  
--name CentOS-7-x86_64 指定创建虚拟机的名字，推荐"简洁"  
--ram 1024 指定创建虚拟机的内存大小  
--cdrom=XX.iso 指定创建虚拟机使用的系统镜像  
--disk path=XX.raw 指定创建虚拟机使用的虚拟磁盘  
--network network=default 指定创建虚拟机使用的网络类型  
--graphics vnc,listen=0.0.0.0 指定访问虚拟机使用的客户端配置信息  
--noautoconsole 禁止配置的客户端自动连接虚拟机

如果出现VNC连接黑屏的情况，需要添加以下两个参数  
--video vga: 强制使用最基础的 VGA 显卡，这是 VNC 兼容性最好的模式。  
--boot cdrom,hd: 强制显式指定先从光盘引导，再从硬盘引导。  
如果都不行的话，改用其他镜像
#### 连接虚拟机
打开vnc-viewer软件  
连接虚拟机10.0.0.12:5900

### 简单操作虚拟机
#### 启动虚拟机
virsh list  
virsh start CentOS-7-x86_64

#### 配置目录
tree /etc/libvirt/qemu  
/etc/libvirt/qemu  
├── autostart  
├── CentOS-7-x86_64.xml  
└── networks   
├── autostart  
│ └── default.xml -> ../default.xml   
└── default.xml  
可以看到：
我们创建的虚拟机配置文件都在 /etc/libvirt/qemu 目录下
这个目录下的networks目录是存放的虚拟机的网络配置，文件名称是default.xml  
CentOS-7-x86_64.xml是我们定义的虚拟机的配置文件，原则上，这个文件只能用virsh edit进行编
辑  
#### 虚拟机配置文件
cat /etc/libvirt/qemu/CentOS-7-x86_64.xml  
#### 网络配置文件  
cat /etc/libvirt/qemu/networks/default.xml
#### 基础功能
virsh list 列出所有活动的虚拟机  
virsh list --all 列出所有活动和不活的的虚拟机  
virsh list --transient 列出所有临时的虚拟机  
virsh list --persistent 列出所有持久的虚拟机  

